#!/bin/zsh -f

zmodload zsh/terminfo

typeset -a name_stack
typeset -a level_stack
typeset -a string_stack

main() {
  stInit
  cat demo-text.txt | parse
  echo
}

have=n

getline() {
  local pat="$1"
  if [[ "$have" != y ]] {
    read line || return 1
    sleep .2
    have=y
  }
  if [[ "$line" =~ "$pat" ]] {
    have=n
    return 0
  }
  return 1
}

unclaim() {
  have=y
}

parse() {
  suite

  if [[ "$have" == y ]] {
    echo "unclaimed line: $line"
  }
}

suite() {
  getline '^Will run' || return 1
  local name="$line"
  start SUITE $name
  while context; do
    :
  done
  stop SUITE $name
}

context() {
  getline '\[k8s\.io\]' || return 1
  local name="$line"
  start CONTEXT $name
  while it || context || info; do
    :
  done
  stop CONTEXT $name
}

it() {
  getline '^\[It\]' || return 1
  local name="$line"
  start IT $name
  while info || each || step || startit; do
    :
  done
  pass || fail || exit 2
  stop IT $name
}

startit() {
  getline '\[It\]$' || return 1
  local name="$line"
  update IT 'RUNNING'
}

pass=0
fail=0

pass() {
  getline '^PASS' || return 1
  (( pass++ ))
  update IT $line
  update SUITE "$pass passed $fail failed"
}

fail() {
  getline '^FAIL' || return 1
  (( fail++ ))
  update IT $line
  update SUITE "$pass passed $fail failed"
}

each() {
  getline '(After|Before)Each' || return 1
  local name="$line"
  start EACH $name
  while info || step; do
    :
  done
  stop EACH $name
}

step() {
  getline '^STEP:' || return 1
  local name="$line"
  start STEP $name
  info
  stop STEP $name
}

info() {
  getline '^INFO' || return 1
  unclaim
  start INFO
  while infoline; do
    :
  done
  stop INFO
}

infoline() {
  getline '^INFO' || return 1
  start INFOLINE "$line"
  stop INFOLINE "$line"
}

indent=0
delta=0
start() {
  local name="$1"
  shift
  if [[ -n "$*" ]] {
    stPush "$name" $(( indent++ )) "$*"
  }
  # shift
  # printf '%*s [%s "%s"\n' $indent '' "$name" "$*"
  # (( indent++ ))
}

update() {
  local name="$1"
  shift
  stUpdate "$name" "$@"
  # printf '%*s <==%s ->"%s"\n' $indent '' "$name" "$*"
}

stop() {
  local name="$1"
  shift
  if [[ -n "$*" ]] {
    (( indent-- ))
  }
  if [[ "$name" == 'INFO' ]] {
    stPopAll 'INFOLINE'
  } elif [[ "$name" == 'EACH' ]] {
    stPopTo 'EACH'
    stPop
  } elif [[ "$name" == 'IT' ]] {
    stPopTo 'IT'
  }
  # (( indent-- ))
  # printf '%*s %s] "%s"\n' $indent '' "$name" "$*"
}

stInit() {
  name_stack=()
  level_stack=()
  string_stack=()
}

# replace current line
stReplace() {
  printf '\r'
  echoti hpa $level_stack[-1]
  echoti el
  printf "$@"
}

stPush() {
  st_push "$@"
  printf '\n%*s%s' $level_stack[-1] '' $string_stack[-1]
}

stPopTo() {
  local name="$1"

  until [[ "$name_stack[-1]" == "$name" ]] {
    stPop
    sleep .1
  }
}

stPopAll() {
  local name="$1"

  until [[ "$name_stack[-1]" != "$name" ]] {
    stPop
    sleep .1
  }
}

stPop() {
  printf '\r'
  echoti el
  echoti cuu1
  shift -p name_stack
  shift -p level_stack
  shift -p string_stack
}

stUpdate() {
  typeset -a ent
  local name="$1"
  shift
  echoti sc
  for (( i = 0; i < $#name_stack; i++ )) {
    j=$(( $#name_stack - i ))
    if [[ "$name_stack[$j]" == "$name" ]] {
      printf '\r'
      echoti hpa "$level_stack[$j]"
      echoti el
      printf "%s -- " $string_stack[$j]
      printf "$@"
      break
    }
    echoti cuu1
  }
  echoti rc
}

st_push() {
  name_stack+=($1)
  level_stack+=($2)
  string_stack+=($3)
}

main "$@"
